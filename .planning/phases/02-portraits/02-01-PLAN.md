---
phase: 02-portraits
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/003_portraits.sql
  - src/lib/validations/portraits.ts
  - src/actions/portraits.ts
autonomous: true

must_haves:
  truths:
    - "Portraits table exists with user_id, storage_path, public_url, label, is_active columns"
    - "Server actions authenticate user before any operation"
    - "Only one portrait per user can have is_active=true"
    - "Delete action prevents deletion when user has only one portrait"
  artifacts:
    - path: "supabase/migrations/003_portraits.sql"
      provides: "Portraits table with RLS policies"
      contains: "CREATE TABLE portraits"
    - path: "src/lib/validations/portraits.ts"
      provides: "Zod schemas for portrait operations"
      exports: ["uploadPortraitSchema", "updateLabelSchema"]
    - path: "src/actions/portraits.ts"
      provides: "Server actions for portrait CRUD"
      exports: ["uploadPortrait", "deletePortrait", "setActivePortrait", "updatePortraitLabel"]
  key_links:
    - from: "src/actions/portraits.ts"
      to: "supabase.from('portraits')"
      via: "server client queries"
      pattern: "supabase\\.from\\(['\"]portraits['\"]\\)"
---

<objective>
Create the portraits database table and server actions for portrait library management.

Purpose: Establishes the data layer for multi-portrait support, replacing the single avatar_url approach from onboarding.
Output: Migration file for portraits table + server actions for upload, delete, set-active, and label operations.
</objective>

<execution_context>
@/Users/frutz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/frutz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-portraits/02-RESEARCH.md

# Existing patterns to follow
@src/actions/onboarding.ts
@src/lib/validations/auth.ts
@supabase/migrations/001_profiles.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create portraits table migration</name>
  <files>supabase/migrations/003_portraits.sql</files>
  <action>
Create migration file with:

1. Portraits table:
   - id: UUID primary key (gen_random_uuid)
   - user_id: UUID references auth.users(id) ON DELETE CASCADE
   - storage_path: TEXT NOT NULL (e.g., "{user_id}/{uuid}.jpg")
   - public_url: TEXT NOT NULL (full public URL from Storage)
   - label: TEXT DEFAULT '' (user-provided label)
   - is_active: BOOLEAN DEFAULT FALSE
   - created_at: TIMESTAMPTZ DEFAULT NOW()
   - updated_at: TIMESTAMPTZ DEFAULT NOW()

2. Enable RLS on portraits table

3. RLS policies:
   - "Users can read own portraits" FOR SELECT USING (auth.uid() = user_id)
   - "Users can insert own portraits" FOR INSERT WITH CHECK (auth.uid() = user_id)
   - "Users can update own portraits" FOR UPDATE USING (auth.uid() = user_id)
   - "Users can delete own portraits" FOR DELETE USING (auth.uid() = user_id)

4. Indexes:
   - portraits_user_id_idx ON portraits(user_id)
   - portraits_is_active_idx ON portraits(user_id, is_active) WHERE is_active = TRUE

5. Reuse update_updated_at() trigger function from 001_profiles.sql:
   - CREATE TRIGGER portraits_updated_at BEFORE UPDATE ON portraits FOR EACH ROW EXECUTE FUNCTION update_updated_at()

6. Storage delete policy (append to file or note for manual addition):
   - Add comment noting that storage delete policy may be needed if not already present

Do NOT create a new update_updated_at function - it already exists from profiles migration.
  </action>
  <verify>File exists at supabase/migrations/003_portraits.sql with CREATE TABLE portraits statement</verify>
  <done>Migration file ready to be run in Supabase SQL Editor</done>
</task>

<task type="auto">
  <name>Task 2: Create Zod validation schemas and server actions</name>
  <files>src/lib/validations/portraits.ts, src/actions/portraits.ts</files>
  <action>
**First, create src/lib/validations/portraits.ts:**

```typescript
import { z } from "zod"

export const uploadPortraitSchema = z.object({
  storagePath: z.string().min(1, "Storage path required"),
  publicUrl: z.string().url("Invalid URL"),
  label: z.string().max(100, "Label too long").optional(),
})

export const updateLabelSchema = z.object({
  portraitId: z.string().uuid("Invalid portrait ID"),
  label: z.string().max(100, "Label too long"),
})

export type UploadPortraitInput = z.infer<typeof uploadPortraitSchema>
export type UpdateLabelInput = z.infer<typeof updateLabelSchema>
```

**Then, create src/actions/portraits.ts:**

Follow the pattern from src/actions/onboarding.ts. All server actions must:
1. Be marked with "use server"
2. Get user via supabase.auth.getUser()
3. Return { error: string } on failure or { success: true } on success
4. Call revalidatePath("/portraits") on success

**uploadPortrait(input: UploadPortraitInput):**
- Validate input with uploadPortraitSchema
- Insert into portraits table with user_id from auth
- If this is user's first portrait (check count), set is_active = true
- Return { success: true, portraitId: string }

**deletePortrait(portraitId: string):**
- Verify portraitId is valid UUID
- Count user's portraits BEFORE deleting
- If count <= 1, return { error: "Cannot delete your only portrait. Upload another first." }
- Fetch portrait to get storage_path and is_active status
- Verify user owns the portrait (user_id matches)
- Delete from storage first (log errors but continue)
- Delete from database
- If deleted portrait was active, set most recent remaining portrait as active
- Return { success: true }

**setActivePortrait(portraitId: string):**
- Verify portraitId is valid UUID
- Deactivate all portraits for this user (UPDATE set is_active = false WHERE user_id)
- Activate the selected portrait (UPDATE set is_active = true WHERE id AND user_id)
- Return { success: true }

**updatePortraitLabel(input: UpdateLabelInput):**
- Validate input with updateLabelSchema
- Update label WHERE id = portraitId AND user_id matches
- Return { success: true }

Import createClient from "@/lib/supabase/server".
Import revalidatePath from "next/cache".
  </action>
  <verify>Run `npx tsc --noEmit` - no TypeScript errors in new files</verify>
  <done>Server actions exported and type-safe, validation schemas ready for use</done>
</task>

</tasks>

<verification>
1. Migration file exists with correct table structure
2. TypeScript compiles without errors: `npx tsc --noEmit`
3. Server actions file exports all 4 functions
4. Validation schemas export types
</verification>

<success_criteria>
- [ ] Migration creates portraits table with all columns (id, user_id, storage_path, public_url, label, is_active, timestamps)
- [ ] RLS policies protect portrait data by user
- [ ] Server actions handle auth check before operations
- [ ] Delete action prevents last portrait deletion
- [ ] Set-active ensures only one active portrait per user
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-portraits/02-01-SUMMARY.md`
</output>
