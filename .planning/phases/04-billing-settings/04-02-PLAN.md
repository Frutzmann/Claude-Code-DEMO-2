---
phase: 04-billing-settings
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/app/api/webhooks/stripe/route.ts
  - src/middleware.ts
  - src/actions/billing.ts
  - src/actions/generations.ts
  - src/lib/validations/generations.ts
autonomous: true

must_haves:
  truths:
    - "Stripe webhooks sync subscription data to database"
    - "Checkout session creates subscription for user"
    - "Customer portal allows subscription management"
    - "Quota check uses Stripe billing period for paid users"
    - "Admin bypasses all quota checks"
  artifacts:
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Stripe webhook handler"
      exports: ["POST"]
    - path: "src/actions/billing.ts"
      provides: "Checkout and portal session creation"
      exports: ["createCheckoutSession", "createPortalSession"]
    - path: "src/actions/generations.ts"
      provides: "Updated quota check with billing period"
      exports: ["getGenerationQuota"]
  key_links:
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "subscriptions table"
      via: "supabase service role client"
      pattern: "supabase\\.from\\('subscriptions'\\)"
    - from: "src/actions/billing.ts"
      to: "stripe.checkout.sessions.create"
      via: "Stripe SDK"
      pattern: "stripe\\.checkout\\.sessions\\.create"
    - from: "src/actions/generations.ts"
      to: "subscriptions table"
      via: "billing period lookup"
      pattern: "from\\('subscriptions'\\)"
---

<objective>
Implement Stripe webhook handling, checkout/portal flows, and billing period-based quota enforcement.

Purpose: This connects Stripe to the database and enables paid subscriptions. The webhook keeps subscription data in sync, checkout enables upgrades, and quota enforcement gates the generation feature.

Output: Working webhook endpoint, billing server actions, updated quota logic.
</objective>

<execution_context>
@/Users/frutz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/frutz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-billing-settings/04-RESEARCH.md

@src/lib/stripe/server.ts
@src/lib/billing/plans.ts
@src/middleware.ts
@src/actions/generations.ts
@src/lib/admin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Stripe webhook handler</name>
  <files>
src/app/api/webhooks/stripe/route.ts
src/middleware.ts
  </files>
  <action>
Create `src/app/api/webhooks/stripe/route.ts` following the pattern from RESEARCH.md:

1. Import Stripe, createClient from @supabase/supabase-js (service role)
2. Define relevantEvents Set: checkout.session.completed, customer.subscription.created/updated/deleted, product.created/updated, price.created/updated
3. POST handler:
   - Get raw body with `request.text()`
   - Verify signature with `stripe.webhooks.constructEvent(body, signature, STRIPE_WEBHOOK_SECRET)`
   - Return 400 if no signature or invalid signature
   - Skip non-relevant events with `{ received: true }`
   - Handle each event type with try/catch, return 500 on handler error

4. Helper functions (all use service role Supabase client):
   - `upsertProduct(product: Stripe.Product)` - upsert to products table
   - `upsertPrice(price: Stripe.Price)` - upsert to prices table, handle type/interval enums
   - `upsertSubscription(subscription: Stripe.Subscription)`:
     - Get user_id from metadata or via getUserIdFromCustomer
     - Convert Unix timestamps to ISO strings (multiply by 1000)
     - Upsert to subscriptions table with all fields
   - `deleteSubscription(subscription: Stripe.Subscription)` - update status to 'canceled', set ended_at
   - `getUserIdFromCustomer(customerId: string)` - lookup customers table

IMPORTANT: Use service role client for webhook processing:
```typescript
import { createClient } from '@supabase/supabase-js'
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)
```

Then update `src/middleware.ts`:
- Add "/api/webhooks/stripe" to the PUBLIC_ROUTES array (webhooks must not require auth)

Note: The existing n8n webhook route already established the pattern of allowing webhooks through middleware.
  </action>
  <verify>
Run `grep -l "stripe.webhooks.constructEvent" src/app/api/webhooks/stripe/route.ts` to confirm webhook verification.
Run `grep "api/webhooks/stripe" src/middleware.ts` to confirm route is public.
  </verify>
  <done>
Webhook handler at /api/webhooks/stripe processes subscription events.
Middleware allows webhook route without authentication.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create billing server actions</name>
  <files>src/actions/billing.ts</files>
  <action>
Create `src/actions/billing.ts` with "use server" directive:

1. **createCheckoutSession(priceId: string)**:
   - Get authenticated user
   - Look up or create Stripe customer:
     - Query customers table for stripe_customer_id
     - If not found, create via `stripe.customers.create({ email, metadata: { supabase_user_id } })`
     - Upsert customer record to customers table
   - Create checkout session:
     - customer: stripeCustomerId
     - mode: 'subscription'
     - payment_method_types: ['card']
     - line_items: [{ price: priceId, quantity: 1 }]
     - success_url: `${NEXT_PUBLIC_APP_URL}/settings?success=true`
     - cancel_url: `${NEXT_PUBLIC_APP_URL}/settings?canceled=true`
     - subscription_data.metadata: { supabase_user_id: user.id } (CRITICAL for webhook)
   - Redirect to session.url

2. **createPortalSession()**:
   - Get authenticated user
   - Query customers table for stripe_customer_id
   - Return error if no customer found
   - Create portal session: `stripe.billingPortal.sessions.create({ customer, return_url })`
   - Redirect to session.url

Import stripe from @/lib/stripe/server, createClient from @/lib/supabase/server.
Use `redirect()` from next/navigation for redirects.
  </action>
  <verify>
Run `grep "createCheckoutSession" src/actions/billing.ts` to confirm function exists.
Run `grep "supabase_user_id" src/actions/billing.ts` to confirm metadata is set correctly.
  </verify>
  <done>
src/actions/billing.ts exports createCheckoutSession and createPortalSession.
Checkout includes supabase_user_id in subscription metadata.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update quota check to use billing period</name>
  <files>
src/actions/generations.ts
src/lib/validations/generations.ts
  </files>
  <action>
Update `src/actions/generations.ts`:

1. Update imports to include getPlanByPriceId, getPlanQuota from @/lib/billing/plans

2. Rewrite `getGenerationQuota()`:
   - Get authenticated user
   - Check if admin (return early with isAdmin: true, limit: Infinity)
   - Query subscriptions table for active/trialing subscription with price_id, current_period_start, current_period_end
   - Determine plan using getPlanByPriceId(subscription?.price_id ?? null)
   - Get quota using getPlanQuota(plan)
   - Determine period:
     - If subscription has period dates: use them
     - Else (free tier): use calendar month start
   - Count generations in period with `.gte('created_at', periodStart.toISOString())`
   - Return { success, used, limit, isAdmin, plan, periodEnd }

3. Update `createGeneration()`:
   - Replace hardcoded FREE_TIER_MONTHLY_QUOTA check with proper billing period logic:
     - Get subscription, determine plan and period (same as getGenerationQuota)
     - Check against getPlanQuota(plan)
   - Update error message to include plan-specific limit

4. Update `src/lib/validations/generations.ts`:
   - Remove FREE_TIER_MONTHLY_QUOTA constant (no longer needed, quotas come from plans.ts)

Note: Keep isAdmin check at the top of both functions for fast-path (admin skips all quota logic).
  </action>
  <verify>
Run `grep "getPlanByPriceId" src/actions/generations.ts` to confirm billing plan lookup.
Run `grep "current_period_start" src/actions/generations.ts` to confirm billing period usage.
Run `grep -c "FREE_TIER_MONTHLY_QUOTA" src/lib/validations/generations.ts` should return 0.
  </verify>
  <done>
getGenerationQuota uses Stripe billing period for paid users, calendar month for free.
createGeneration enforces plan-specific quotas.
FREE_TIER_MONTHLY_QUOTA removed from validations (now in plans.ts).
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `curl -X POST http://localhost:3000/api/webhooks/stripe` returns 400 (no signature) - proves route works
2. `grep "createCheckoutSession\|createPortalSession" src/actions/billing.ts` shows both functions
3. `grep "current_period_start" src/actions/generations.ts` shows billing period logic
4. `npx tsc --noEmit` passes without errors
</verification>

<success_criteria>
- Webhook handler processes all subscription lifecycle events
- Webhook route is publicly accessible (in middleware PUBLIC_ROUTES)
- createCheckoutSession creates Stripe Checkout with proper metadata
- createPortalSession redirects to Stripe Customer Portal
- getGenerationQuota returns plan name and billing period end date
- createGeneration enforces quota based on user's subscription plan
- Admin users bypass all quota checks
</success_criteria>

<output>
After completion, create `.planning/phases/04-billing-settings/04-02-SUMMARY.md`
</output>
