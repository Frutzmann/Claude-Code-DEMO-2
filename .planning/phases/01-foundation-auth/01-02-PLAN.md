---
phase: 01-foundation-auth
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .env.local
  - .env.example
  - src/lib/supabase/client.ts
  - src/lib/supabase/server.ts
  - src/lib/supabase/middleware.ts
  - src/lib/admin.ts
  - supabase/migrations/001_profiles.sql
  - supabase/migrations/002_storage.sql
autonomous: true
user_setup:
  - service: supabase
    why: "Database and authentication"
    env_vars:
      - name: NEXT_PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API -> Project URL"
      - name: NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> anon public key"
      - name: ADMIN_EMAIL
        source: "Your admin email address (e.g., admin@example.com)"
    dashboard_config:
      - task: "Create 'portraits' storage bucket"
        location: "Supabase Dashboard -> Storage -> New bucket (public: yes)"

must_haves:
  truths:
    - "Supabase client can connect to project"
    - "Profiles table exists with onboarding_completed column"
    - "New auth users automatically get profile row"
    - "Admin email is identifiable via environment variable"
  artifacts:
    - path: "src/lib/supabase/client.ts"
      provides: "Browser Supabase client"
      contains: "createBrowserClient"
    - path: "src/lib/supabase/server.ts"
      provides: "Server Supabase client"
      contains: "createServerClient"
    - path: "src/lib/supabase/middleware.ts"
      provides: "Middleware session updater"
      contains: "updateSession"
    - path: "src/lib/admin.ts"
      provides: "Admin check utility"
      contains: "isAdmin"
    - path: "supabase/migrations/001_profiles.sql"
      provides: "Profiles table and trigger"
      contains: "CREATE TABLE profiles"
  key_links:
    - from: "src/lib/supabase/server.ts"
      to: "cookies()"
      via: "next/headers import"
      pattern: "import.*cookies.*from.*next/headers"
    - from: "supabase/migrations/001_profiles.sql"
      to: "auth.users"
      via: "foreign key reference"
      pattern: "REFERENCES auth.users"
---

<objective>
Setup Supabase clients (browser, server, middleware), database schema with profiles table and auto-creation trigger, and storage bucket configuration.

Purpose: Establish the backend infrastructure that auth and onboarding will use.
Output: Working Supabase connection with profiles table, storage bucket for portraits, and admin identification utility.
</objective>

<execution_context>
@/Users/frutz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/frutz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-auth/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase client utilities</name>
  <files>
    .env.local
    .env.example
    src/lib/supabase/client.ts
    src/lib/supabase/server.ts
    src/lib/supabase/middleware.ts
    src/lib/admin.ts
  </files>
  <action>
    1. Create `.env.example` with placeholder values:
       ```
       NEXT_PUBLIC_SUPABASE_URL=your-project-url
       NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY=your-anon-key
       NEXT_PUBLIC_APP_URL=http://localhost:3000
       ADMIN_EMAIL=admin@example.com
       ```

    2. Create `.env.local` with the same structure (user will fill in real values).
       Add `.env.local` to `.gitignore` if not already there.

    3. Create `src/lib/supabase/client.ts`:
       - Export `createClient()` function using `createBrowserClient` from @supabase/ssr
       - Use NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY
       - Pattern from RESEARCH.md

    4. Create `src/lib/supabase/server.ts`:
       - Export async `createClient()` function using `createServerClient` from @supabase/ssr
       - Import `cookies` from next/headers (await cookies())
       - Implement getAll/setAll cookie handlers per RESEARCH.md
       - setAll should catch errors (for Server Component usage)

    5. Create `src/lib/supabase/middleware.ts`:
       - Export async `updateSession(request: NextRequest)` function
       - Create Supabase client with cookie handlers that update both request and response
       - Call `supabase.auth.getUser()` (NOT getSession - security)
       - Return { supabaseResponse, user, supabase }
       - Pattern exactly from RESEARCH.md

    6. Create `src/lib/admin.ts`:
       - Export `isAdmin(email: string | undefined): boolean` function
       - Check if email matches process.env.ADMIN_EMAIL
       - Return false if ADMIN_EMAIL not set or email undefined
  </action>
  <verify>
    TypeScript compilation: `npx tsc --noEmit` should pass
    Files exist: ls src/lib/supabase/ should show client.ts, server.ts, middleware.ts
    Env example exists: cat .env.example should show template
  </verify>
  <done>Three Supabase client utilities created, env template ready, admin check utility working</done>
</task>

<task type="auto">
  <name>Task 2: Create database migration files</name>
  <files>
    supabase/migrations/001_profiles.sql
    supabase/migrations/002_storage.sql
  </files>
  <action>
    1. Create directory: `mkdir -p supabase/migrations`

    2. Create `supabase/migrations/001_profiles.sql`:
       ```sql
       -- Profiles table linked to auth.users
       CREATE TABLE IF NOT EXISTS profiles (
         id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
         email TEXT,
         full_name TEXT,
         avatar_url TEXT,
         onboarding_completed BOOLEAN DEFAULT FALSE,
         created_at TIMESTAMPTZ DEFAULT NOW(),
         updated_at TIMESTAMPTZ DEFAULT NOW()
       );

       -- Enable RLS
       ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

       -- Users can read own profile
       CREATE POLICY "Users can read own profile"
       ON profiles FOR SELECT
       USING (auth.uid() = id);

       -- Users can update own profile
       CREATE POLICY "Users can update own profile"
       ON profiles FOR UPDATE
       USING (auth.uid() = id);

       -- Function to create profile on signup
       CREATE OR REPLACE FUNCTION public.handle_new_user()
       RETURNS TRIGGER AS $$
       BEGIN
         INSERT INTO public.profiles (id, email, full_name)
         VALUES (
           NEW.id,
           NEW.email,
           COALESCE(NEW.raw_user_meta_data->>'full_name', '')
         );
         RETURN NEW;
       END;
       $$ LANGUAGE plpgsql SECURITY DEFINER;

       -- Trigger on auth.users insert
       DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
       CREATE TRIGGER on_auth_user_created
         AFTER INSERT ON auth.users
         FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

       -- Update timestamp trigger
       CREATE OR REPLACE FUNCTION update_updated_at()
       RETURNS TRIGGER AS $$
       BEGIN
         NEW.updated_at = NOW();
         RETURN NEW;
       END;
       $$ LANGUAGE plpgsql;

       DROP TRIGGER IF EXISTS profiles_updated_at ON profiles;
       CREATE TRIGGER profiles_updated_at
         BEFORE UPDATE ON profiles
         FOR EACH ROW EXECUTE FUNCTION update_updated_at();
       ```

    3. Create `supabase/migrations/002_storage.sql`:
       ```sql
       -- Storage bucket for portrait images
       -- Note: Run this in Supabase Dashboard SQL Editor
       -- The bucket itself is created via Dashboard UI

       -- Allow authenticated users to upload to their folder
       CREATE POLICY "Users can upload own portraits"
       ON storage.objects FOR INSERT
       WITH CHECK (
         bucket_id = 'portraits' AND
         auth.uid()::text = (storage.foldername(name))[1]
       );

       -- Allow users to read their own portraits
       CREATE POLICY "Users can read own portraits"
       ON storage.objects FOR SELECT
       USING (
         bucket_id = 'portraits' AND
         auth.uid()::text = (storage.foldername(name))[1]
       );

       -- Allow users to delete their own portraits
       CREATE POLICY "Users can delete own portraits"
       ON storage.objects FOR DELETE
       USING (
         bucket_id = 'portraits' AND
         auth.uid()::text = (storage.foldername(name))[1]
       );

       -- Allow public read access to portraits (needed for n8n workflow)
       CREATE POLICY "Public can read portraits"
       ON storage.objects FOR SELECT
       USING (bucket_id = 'portraits');
       ```

    4. Add a README in supabase/migrations/:
       ```markdown
       # Database Migrations

       Run these SQL files in Supabase Dashboard -> SQL Editor in order:

       1. `001_profiles.sql` - Creates profiles table and auto-creation trigger
       2. `002_storage.sql` - Creates storage policies for portraits bucket

       Before running 002_storage.sql:
       - Create 'portraits' bucket in Storage (make it public)
       ```
  </action>
  <verify>
    Files exist: ls supabase/migrations/ should show 001_profiles.sql, 002_storage.sql
    SQL syntax valid (basic check): grep "CREATE TABLE" supabase/migrations/001_profiles.sql should find the table creation
  </verify>
  <done>Migration files created with profiles table, RLS policies, auto-creation trigger, and storage policies</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes (no TypeScript errors)
2. All lib files exist in src/lib/supabase/
3. Migration files exist in supabase/migrations/
4. .env.example has all required variables
</verification>

<success_criteria>
- Browser client utility exports createClient()
- Server client utility exports async createClient() with cookie handling
- Middleware utility exports updateSession() returning user and response
- Admin utility exports isAdmin() checking ADMIN_EMAIL env var
- Migration file creates profiles table with:
  - id (UUID, FK to auth.users)
  - email, full_name, avatar_url (TEXT)
  - onboarding_completed (BOOLEAN, default false)
  - created_at, updated_at (TIMESTAMPTZ)
- Migration file creates trigger for auto-profile creation
- Migration file enables RLS with user-only policies
- Storage migration creates policies for portraits bucket
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-auth/01-02-SUMMARY.md`
</output>
